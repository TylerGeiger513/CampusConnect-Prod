{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Campus Connect Documentation","text":"<p>Course: CSC 468 \u2013 Cloud Computing  </p> <p>Institution: West Chester University  </p> <p>Professor: Dr. Ngo</p> <p>Semester: Spring 2025</p>"},{"location":"#members-alphabetical-order","title":"Members (Alphabetical Order)","text":"<ul> <li> <p>Perez Abhuilmen </p> <ul> <li> LinkedIn </li> <li> GitHub</li> </ul> </li> <li> <p>Alex Cooper </p> <ul> <li> LinkedIn </li> <li> GitHub</li> </ul> </li> <li> <p>Tyler Geiger </p> <ul> <li> LinkedIn </li> <li> GitHub</li> </ul> </li> <li> <p>Kadin Matotek </p> <ul> <li> LinkedIn </li> <li> GitHub</li> </ul> </li> </ul>"},{"location":"#repositories","title":"Repositories","text":"<ul> <li>Production repository:      GitHub</li> <li>Testing / Development     GitHub</li> </ul>"},{"location":"#project-demo","title":"Project Demo","text":""},{"location":"#vision","title":"Vision","text":"<p>Our vision is to create an application tailored for university students that enables them to:</p> <ul> <li>Connect with peers on campus  </li> <li>Collaborate on class projects  </li> <li>Study and chat together in real time  </li> </ul> <p>Campus Connect offers a clean, minimal interface inspired by platforms like Discord, but focused specifically on academic connections and collaboration.</p>"},{"location":"#overview","title":"Overview","text":"<p>Campus Connect is a full-stack, real-time chat platform built to enhance campus communication and productivity. Our system is designed to offer:</p> <ul> <li>Private messaging and group chats</li> <li>Friend system with request handling</li> <li>Secure session management with Redis</li> <li>WebSocket-powered live messaging</li> <li>Modular architecture with full CI/CD pipeline</li> </ul>"},{"location":"#technology-stack","title":"Technology Stack","text":"<ul> <li>Backend: NestJS, TypeScript, MongoDB (Mongoose), Redis, Express Sessions  </li> <li>Frontend: ReactJS (served statically via Nginx)  </li> <li>Real-time: Socket.IO for live messaging  </li> <li>Security: AES-256-CBC encrypted sessions, AuthGuard protection, bcrypt password hashing  </li> <li>CI/CD: GitHub webhook \u2192 CloudLab Portal API \u2192 Skaffold \u2192 Helm \u2192 Kubernetes (Minikube)  </li> <li>TODO: Secrets Management:: Using Helm or Github Secrets</li> </ul>"},{"location":"#features-todo-list","title":"Features &amp; TODO List","text":""},{"location":"#1-authentication-authorization","title":"1. Authentication &amp; Authorization","text":"<ul> <li> User registration and login endpoints  </li> <li> Session management with encrypted Redis store  </li> <li> AuthGuard for protected routes  </li> <li> Password hashing and verification  </li> <li> (Idea?) Email verification and password reset support  </li> </ul>"},{"location":"#2-friend-system","title":"2. Friend System","text":"<ul> <li> Friend request model with statuses (pending, accepted, declined)  </li> <li> Extended user schema for friend tracking  </li> <li> API to send/accept/decline friend requests  </li> <li> Endpoint to fetch confirmed friends list  </li> <li> Blocklist handling in schema  </li> <li> Basic UI to manage friend requests  </li> <li> Real-time friend request notifications </li> <li> Notifications rendered on frontend    </li> </ul>"},{"location":"#3-direct-messaging","title":"3. Direct Messaging","text":"<ul> <li> Create &amp; retrieve DM channel between users  </li> <li> Design message schema (content, sender, timestamp)  </li> <li> WebSocket event on message send  </li> <li> Load &amp; persist message history  </li> <li> Input box and infinite scroll UI  </li> </ul>"},{"location":"#4-live-messaging-socketio","title":"4. Live Messaging (Socket.IO)","text":"<ul> <li> Gateway for <code>/channels</code> namespace  </li> <li> EventEmitter-driven real-time broadcasting  </li> <li> UI listens to <code>messageReceived</code> events  </li> <li> Automatically join/leave channel rooms via WebSocket events  </li> <li> Sync unread message indicators  </li> </ul>"},{"location":"#5-university-group-chat","title":"5. University Group Chat","text":"<ul> <li> Group channel model (reusing base channel schema)  </li> <li> Add group metadata (title, description, creator)  </li> <li> Join/leave endpoints for university-based channels  </li> <li> Manage group participants  </li> <li> Extend live messaging to group channels  </li> </ul>"},{"location":"#6-classroom-subgroups","title":"6. Classroom &amp; Subgroups","text":"<ul> <li> Define classroom group and nested subgroup schema  </li> <li> Support roles: student, instructor, TA  </li> <li> Channel-specific permissions for moderation  </li> <li> Role-based message visibility and muting  </li> <li> Admin UI to manage members and roles  </li> </ul>"},{"location":"#7-secrets-cicd","title":"7. Secrets &amp; CI/CD","text":"<ul> <li> Helm values.yaml for managing encryption key, Redis URI, session secret  </li> <li> Skaffold handles builds for frontend/backend separately  </li> <li> GitHub webhook \u2192 shell script triggers Skaffold deploy  </li> <li> CloudLab <code>profiles.py</code> configuration triggers Minikube pod rollout  </li> <li> Add secure secret management using github secrets or helm_secrets </li> <li> Monitor builds and auto-fail bad deploys  </li> </ul>"},{"location":"#summary","title":"Summary","text":"<p>Campus Connect is not just a messaging platform \u2014 it's a collaborative academic tool designed for students, by students. With full-stack ownership, real-time architecture, and secure deployment, it offers a scalable foundation for academic communities and class groups to communicate, share, and succeed.</p>"},{"location":"architecture/","title":"Cloud Architecture","text":"<p>Campus Connect is fully containerized and deployed inside a single-node Kubernetes cluster (via Minikube) on CloudLab. All components are managed using Helm and exposed through an NGINX ingress controller.</p>"},{"location":"architecture/#application-overview","title":"Application Overview","text":"<p>The app consists of:</p> <ul> <li>A React frontend built and served through NGINX</li> <li>A Node.js/NestJS backend connected to MongoDB and Redis</li> <li>Kubernetes-managed services for container networking</li> <li>A Helm-based config injection system for runtime flexibility</li> </ul> <pre><code>flowchart LR\n  subgraph \"Kubernetes Cluster (Minikube)\"\n    Ingress[NGINX Ingress Controller&lt;br&gt;campus-connect-ingress]\n\n    Frontend[Frontend Pod&lt;br&gt;campus-connect-frontend]\n    Backend[Backend Pod&lt;br&gt;campus-connect-backend]\n    Redis[Redis Pod&lt;br&gt;redis]\n    Mongo[MongoDB Pod&lt;br&gt;mongo]\n\n    Ingress --&gt;|HTTP Requests| Frontend\n    Ingress --&gt;|/api, /socket.io| Backend\n\n    Backend --&gt;|Sessions| Redis\n    Backend --&gt;|Database| Mongo\n  end\n\n  User[User Browser&lt;br&gt;cloudlab.hostname] --&gt; Ingress</code></pre>"},{"location":"architecture/#backend-container","title":"Backend Container","text":"<p>The backend is a stateless Node.js API built with NestJS, containerized using a multi-stage Dockerfile.</p> Dockerfile (Backend) <pre><code>FROM node:20-alpine AS builder\nWORKDIR /app\n\nCOPY package*.json ./\nRUN npm install --production\nCOPY . .\n\nRUN npm install -g @nestjs/cli\n\nRUN addgroup -S appgroup &amp;&amp; adduser -S appuser -G appgroup\nRUN chown -R appuser:appgroup /app\nUSER appuser\n\nENV NODE_ENV=production\nEXPOSE ${BACKEND_PORT}\n\nCMD [\"npm\", \"run\", \"start\"]\n</code></pre> <ul> <li>Non-root user (<code>appuser</code>) for improved security</li> <li>Uses environment variables passed via ConfigMap</li> <li>Exposes port <code>3000</code> inside the cluster</li> <li>All logic resides in memory (stateless), with Redis and Mongo for storage/session</li> </ul>"},{"location":"architecture/#frontend-container","title":"Frontend Container","text":"<p>The frontend is built as a static React site, then served through an NGINX container with custom configuration. This also acts as a reverse proxy for backend API and WebSocket traffic.</p> Dockerfile (Frontend) <pre><code># Build React App\nFROM node:20-alpine AS build\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\n# Serve with NGINX\nFROM nginx:alpine\nCOPY --from=build /app/build /usr/share/nginx/html\nCOPY nginx/default.conf.template /etc/nginx/conf.d/default.conf.template\nCOPY nginx/nginx.conf /etc/nginx/nginx.conf\n\nRUN mkdir -p /var/cache/nginx \\\n &amp;&amp; chown -R nginx:nginx /usr/share/nginx /var/cache/nginx /etc/nginx\n\nUSER nginx\nEXPOSE 80\n\nCMD [\"/bin/sh\", \"-c\", \"envsubst '$DOMAIN $NGINX_BACKEND_UPSTREAM' &lt; /etc/nginx/conf.d/default.conf.template &gt; /etc/nginx/conf.d/default.conf &amp;&amp; nginx -g 'pid /tmp/nginx.pid; daemon off;'\"]\n</code></pre> <ul> <li>NGINX config is dynamically rendered at runtime using <code>envsubst</code></li> <li>Handles frontend routing and API proxying</li> </ul>"},{"location":"architecture/#nginx","title":"NGINX","text":"<p>The frontend container uses a templated NGINX config to:</p> <ul> <li>Serve static frontend files (<code>/</code>)</li> <li>Proxy API traffic to the backend (<code>/api</code>)</li> <li>Proxy WebSocket traffic to backend endpoints (e.g., <code>/notifications/socket.io</code>)</li> </ul> default.conf.template <pre><code>server {\n  listen 80;\n  server_name $DOMAIN;\n\n  location /api/ {\n    proxy_pass http://$NGINX_BACKEND_UPSTREAM/api/;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n  }\n\n  location /notifications/socket.io {\n    proxy_pass http://$NGINX_BACKEND_UPSTREAM/notifications/socket.io;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    proxy_set_header Host $host;\n  }\n\n  location /channels/socket.io {\n    proxy_pass http://$NGINX_BACKEND_UPSTREAM/channels/socket.io;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    proxy_set_header Host $host;\n  }\n\n  location / {\n    root /usr/share/nginx/html;\n    try_files $uri /index.html;\n  }\n}\n</code></pre> <p>This configuration allows all services to run behind a single domain using paths like:</p> <ul> <li><code>/</code> \u2192 React frontend</li> <li><code>/api/</code> \u2192 Backend REST API</li> <li><code>/channels/socket.io</code> \u2192 WebSocket real-time messaging</li> </ul> <pre><code>flowchart LR\n  User[\"User Request: (hostname -f)\"] --&gt; NGINX_Frontend[\"NGINX (Frontend Container)\"]\n\n  NGINX_Frontend --&gt;|\"/\"| ReactApp[\"/usr/share/nginx/html\"]\n\n  NGINX_Frontend --&gt;|\"/api/\"| BackendAPI[campus-connect-backend-service:3000]\n\n  NGINX_Frontend --&gt;|\"/notifications/socket.io\"| WS1[campus-connect-backend-service:3000/notifications/socket.io]\n  NGINX_Frontend --&gt;|\"/channels/socket.io\"| WS2[campus-connect-backend-service:3000/channels/socket.io]</code></pre>"},{"location":"architecture/#runtime-configuration-via-helm","title":"Runtime Configuration via Helm","text":"<p>At deploy time, values like <code>DOMAIN</code> and service hostnames are injected into the container via:</p> <ul> <li>Helm templates (from <code>values.yaml</code>)</li> <li>Kubernetes <code>ConfigMap</code>s</li> <li>Environment variable substitution at container startup (<code>envsubst</code>)</li> </ul> <p>This allows switching between environments (local, CloudLab) without rebuilding containers.</p> <p>Security Notes</p> <ul> <li>All containers run as non-root users</li> <li>Sensitive values like passwords and encryption keys are currently in plain-text (TODO: migrate to Kubernetes/Helm Secrets)</li> </ul>"},{"location":"auth/","title":"Authentication &amp; Authorization","text":"<p>Campus Connect implements session-based authentication using a combination of MongoDB for user records and Redis for session storage. The system is secure, stateless on the backend, and designed to support both HTTP and WebSocket authentication flows.</p>"},{"location":"auth/#overview","title":"Overview","text":"<p>Authentication: verifies the identity of users (login/signup + session).</p> <p>Authorization: determines whether an authenticated user has permission to perform a given action (e.g., access channel, edit message, etc).</p> <p>Implemented via:</p> <ul> <li>Session cookies (<code>connect.sid</code>)</li> <li>Encrypted Redis session store</li> <li>Guards (<code>AuthGuard</code>, <code>ChannelsGuard</code>)</li> <li>Decorators like <code>@CurrentUser()</code></li> <li>Explicit user access logic (e.g., <code>channel.participants.includes(userId)</code>)</li> </ul>"},{"location":"auth/#auth-flow","title":"Auth Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Backend\n    participant MongoDB\n    participant Redis\n\n    Client-&gt;&gt;+Backend: POST /auth/signup\n    Backend-&gt;&gt;+MongoDB: Create user\n    MongoDB--&gt;&gt;-Backend: New user\n    Backend-&gt;&gt;+Redis: Save session with userId\n    Redis--&gt;&gt;-Backend: OK\n    Backend--&gt;&gt;-Client: Set-Cookie: connect.sid\n\n    Client-&gt;&gt;+Backend: POST /auth/login\n    Backend-&gt;&gt;+MongoDB: Validate credentials\n    MongoDB--&gt;&gt;-Backend: User OK\n    Backend-&gt;&gt;+Redis: Save session with userId\n    Redis--&gt;&gt;-Backend: OK\n    Backend--&gt;&gt;-Client: Set-Cookie: connect.sid</code></pre>"},{"location":"auth/#session-lifecycle","title":"Session Lifecycle","text":"<ul> <li>Managed via express-session with Redis backend</li> <li>Sessions are:<ul> <li>Signed with <code>SESSION_SECRET</code></li> <li>Encrypted with AES-256</li> <li>Expire after 1 day (configurable via TTL)</li> </ul> </li> </ul> <p>Each session is stored in Redis with key format: <code>session:{sessionId}</code></p>"},{"location":"auth/#middleware-guards","title":"Middleware &amp; Guards","text":""},{"location":"auth/#session-middleware","title":"Session Middleware","text":"<p>Parses and attaches session data to each request.</p> session.middleware.ts<pre><code>req.session.userId = userId;\n</code></pre>"},{"location":"auth/#authguard","title":"AuthGuard","text":"<p>Used to protect any route that requires login.</p> auth.guard.ts<pre><code>return Boolean(request.session &amp;&amp; request.session.userId);\n</code></pre>"},{"location":"auth/#channelsguard","title":"ChannelsGuard","text":"<p>Used for routes requiring channel-level access.</p> <ul> <li>Rejects requests if <code>channelId</code> not associated with <code>userId</code></li> <li>Bypasses certain open routes (like getDMChannel)</li> </ul> channels.guard.ts<pre><code>if (!channel.participants.includes(userId)) throw new ForbiddenException();\n</code></pre>"},{"location":"auth/#auth-decorator","title":"Auth Decorator","text":""},{"location":"auth/#currentuser","title":"<code>@CurrentUser()</code>","text":"<p>Extracts user ID from session.</p> <p>Used in controller methods to avoid manually accessing <code>req.session</code>.</p> auth/current-user.decorator.ts<pre><code>return request.session ? request.session.userId || null : null;\n</code></pre>"},{"location":"auth/#protected-routes","title":"Protected Routes","text":"auth.controller.ts<pre><code>@UseGuards(AuthGuard)\n@Get('profile')\ngetProfile(@CurrentUser() userId: string) {\n  ...\n}\n</code></pre>"},{"location":"auth/#login-signup-api","title":"Login / Signup API","text":""},{"location":"auth/#post-authsignup","title":"POST <code>/auth/signup</code>","text":"<p>Creates a user and starts a session.</p> <pre><code>{\n  \"email\": \"alice@school.edu\",\n  \"username\": \"alice123\",\n  \"password\": \"securepass\",\n  \"campus\": \"West\"\n}\n</code></pre>"},{"location":"auth/#post-authlogin","title":"POST <code>/auth/login</code>","text":"<p>Logs in and saves session with <code>userId</code>.</p> <pre><code>{\n  \"identifier\": \"alice123\",  // email, username, or id\n  \"password\": \"securepass\"\n}\n</code></pre>"},{"location":"auth/#post-authlogout","title":"POST <code>/auth/logout</code>","text":"<p>Destroys session by deleting from Redis.</p>"},{"location":"auth/#get-authsession","title":"GET <code>/auth/session</code>","text":"<p>Returns <code>{ userId }</code> if session is valid.</p>"},{"location":"auth/#websocket-authentication","title":"WebSocket Authentication","text":"<pre><code>sequenceDiagram\n    participant Browser\n    participant Gateway\n    participant Redis\n\n    Browser-&gt;&gt;Gateway: Connect with connect.sid cookie\n    Gateway-&gt;&gt;Redis: Get session:connect.sid\n    Redis--&gt;&gt;Gateway: { userId: abc123 }\n    Gateway--&gt;&gt;Browser: Connection accepted</code></pre> <p>Validation is done during <code>handleConnection</code>:</p> <pre><code>const session = await sessionService.getSessionFromRawCookie(rawCookie);\nif (!session?.userId) client.disconnect();\n</code></pre>"},{"location":"auth/#authorization-logic","title":"Authorization Logic","text":"<p>Campus Connect does not use roles/permissions currently.</p> <p>Instead, all authorization is enforced manually:</p> <ul> <li>Channels:<ul> <li>Must be participant to read, write, or fetch messages</li> </ul> </li> <li>Messages:<ul> <li>Can only edit/delete if <code>senderId === userId</code></li> </ul> </li> <li>Friends:<ul> <li>Cannot send requests to self</li> <li>Cannot block users already blocked</li> </ul> </li> </ul> <p>Example:</p> channels.guard.ts<pre><code>if (!channel.participants.includes(userId)) {\n  throw new ForbiddenException('You are not a participant of this channel.');\n}\n</code></pre>"},{"location":"auth/#password-handling","title":"Password Handling","text":"<p>Passwords are never stored in plaintext.</p> <ul> <li>Hashing: <code>bcrypt.hash(password, 10)</code></li> <li>Verification: <code>bcrypt.compare(input, storedHash)</code></li> </ul> users.service.ts<pre><code>if (!(await comparePasswords(password, user.password))) {\n  throw new UnauthorizedException();\n}\n</code></pre>"},{"location":"channels/","title":"Channels &amp; Messaging","text":"<p>Campus Connect enables real-time direct messaging between users, organized into channels. This system supports:</p> <ul> <li>Direct Messaging (DMs) with unique channel instances</li> <li>Message creation, retrieval, editing, and deletion</li> <li>Channel-based access control via guards</li> <li>Real-time WebSocket updates per channel</li> </ul> ER Diagram <pre><code>erDiagram\n    USER ||--o{ CHANNEL : participates_in\n    USER ||--o{ MESSAGE : sends\n    CHANNEL ||--o{ MESSAGE : contains\n\n    USER {\n        string _id\n        string username\n    }\n\n    CHANNEL {\n        string _id\n        string type\n        string name\n        string[] participants\n    }\n\n    MESSAGE {\n        string _id\n        string channelId\n        string senderId\n        string content\n        boolean edited\n        date createdAt\n    }</code></pre>"},{"location":"channels/#channel-types","title":"Channel Types","text":"<ul> <li>DM: Private channel between two users</li> <li>GROUP: Multi-user channels (not yet implemented)</li> </ul>"},{"location":"channels/#endpoints","title":"Endpoints","text":""},{"location":"channels/#get-channels","title":"GET <code>/channels</code>","text":"<p>Returns all channels the current user is a participant in.</p>"},{"location":"channels/#post-channelschannelgetdmchannel","title":"POST <code>/channels/channel/getDMChannel</code>","text":"<p>Creates or retrieves a DM channel between the current user and another user.</p> <pre><code>{ \"userId\": \"targetUserId\" }\n</code></pre>"},{"location":"channels/#messaging","title":"Messaging","text":""},{"location":"channels/#post-channelsmessage","title":"POST <code>/channels/message</code>","text":"<p>Sends a message to a channel.</p> <pre><code>{\n  \"channelId\": \"abc123\",\n  \"content\": \"Hello world\"\n}\n</code></pre>"},{"location":"channels/#get-channelschannelidmessages","title":"GET <code>/channels/:channelId/messages</code>","text":"<p>Returns all messages in the specified channel, sorted by creation time.</p>"},{"location":"channels/#post-channelsmessagemessageidedit","title":"POST <code>/channels/message/:messageId/edit</code>","text":"<p>Edits a message if the sender matches the current user.</p> <pre><code>{\n  \"content\": \"Edited message content\"\n}\n</code></pre>"},{"location":"channels/#post-channelsmessagemessageiddelete","title":"POST <code>/channels/message/:messageId/delete</code>","text":"<p>Deletes a message if the sender is the current user.</p>"},{"location":"channels/#channel-access-control","title":"Channel Access Control","text":"<p>All routes are protected by the <code>ChannelsGuard</code>.</p> <ul> <li>Verifies the user is a participant in the given channel</li> <li>Allows bypass for DM creation (<code>/channel/getDMChannel</code>)</li> <li>Returns <code>403 Forbidden</code> if unauthorized</li> </ul>"},{"location":"channels/#real-time-messaging","title":"Real-Time Messaging","text":"<p>Messages are emitted to clients using Socket.IO under the <code>/channels</code> namespace.</p>"},{"location":"channels/#websocket-events","title":"WebSocket Events","text":""},{"location":"channels/#joinchannel","title":"<code>joinChannel</code>","text":"<p>Client joins a Socket.IO room by channel ID.</p>"},{"location":"channels/#leavechannel","title":"<code>leaveChannel</code>","text":"<p>Client leaves the specified room.</p>"},{"location":"channels/#messagesent-server-internal","title":"<code>message.sent</code> (Server Internal)","text":"<p>When a message is sent, the <code>ChannelsGateway</code> listens to this event and broadcasts it via <code>messageReceived</code>.</p>"},{"location":"channels/#messagereceived","title":"<code>messageReceived</code>","text":"<p>Clients listening on a channel receive new messages in real-time.</p>"},{"location":"channels/#message-lifecycle","title":"Message Lifecycle","text":"<ol> <li>Client sends message via HTTP \u2192 <code>POST /channels/message</code></li> <li>Backend saves message and emits \u2192 <code>message.sent</code></li> <li>Gateway receives event and emits to clients in room \u2192 <code>messageReceived</code></li> </ol>"},{"location":"channels/#websocket-authentication","title":"WebSocket Authentication","text":"<p>On socket connection, the server:</p> <ul> <li>Parses the <code>connect.sid</code> cookie</li> <li>Verifies session with Redis</li> <li>Disconnects unauthenticated clients</li> </ul>"},{"location":"ci_cd/","title":"CI/CD &amp; Deployment Setup","text":""},{"location":"ci_cd/#1-deployment-setup","title":"1. Deployment Setup","text":"<p>One of our biggest technical challenges was setting up a development workflow that worked both locally on Windows and for production-like deployments on CloudLab (Linux). Since Kubernetes behaves differently across platforms, we needed a system that could abstract those differences and streamline the process.</p> <p>We decided to use Minikube, Skaffold, and Helm.</p> <p>These tools allow us to:</p> <ul> <li>Develop and test services locally with real Kubernetes behavior.</li> <li>Dynamically configure services depending on the environment (dev or prod).</li> <li>Deploy with fast cached rebuilds.</li> </ul> Skaffold Integrations <p>Skaffold manages the entire build-deploy process, automatically rebuilding and redeploying services when code changes. This significantly improves our development speed, especially with Node.js on a slow network connection where rebuilding and downloading <code>node_modules</code> can take ages.</p> skaffold.yaml<pre><code>build:\nartifacts:\n    - image: campus-connect-backend\n    context: backend\n    docker:\n        dockerfile: Dockerfile.backend.prod\n    - image: campus-connect-frontend\n    context: frontend\n    docker:\n        dockerfile: Dockerfile.frontend.prod\n</code></pre> <p>Skaffold also supports profiles, which allow us to use different configuration values and behaviors depending on whether we're developing locally or deploying to CloudLab.</p> skaffold.yaml<pre><code># Development Profile (Local Machine)\nprofiles:\n- name: dev\n    deploy:\n    helm:\n        releases:\n        - name: campus-connect\n            chartPath: ./helm\n            valuesFiles:\n            - ./helm/values.dev.yaml\n            setValueTemplates:\n            domain: \"localhost\"  # Passed to Helm for templating\n# Production Profile (Cloudlab)\n- name: prod\n    deploy:\n    helm:\n        releases:\n        - name: campus-connect\n            chartPath: ./helm\n            valuesFiles:\n            - ./helm/values.prod.yaml\n            setValueTemplates:\n            domain: '{{cmd \"hostname\" \"-f\"}}'  # Injects CloudLab hostname at runtime\n</code></pre> <p>This setup allows us to toggle between environments simply by changing the Skaffold profile in the command line: </p> <pre><code>skaffold run --p dev \nskaffold run --p prod\n</code></pre> Helm \u2013 Environment Templating <p>Helm is used to manage our Kubernetes manifests. Instead of hardcoding values like the <code>domain</code> (used in ingress, nginx, backend CORS settings, etc...), we inject them at deploy time using Helm and Skaffold.</p> <p>In production, for example, we inject the domain dynamically to resolve to the cloudlab environments hostname using:</p> skaffold.yaml<pre><code>setValueTemplates:\n    domain: '{{cmd \"hostname\" \"-f\"}}'\n</code></pre> <p>The <code>domain</code> value is then injected into multiple resources using Helm Templating:</p> ingress.yaml<pre><code>rules:\n  - host: \"{{ .Values.domain }}\"\n</code></pre> configmap.yaml<pre><code>data:\n  DOMAIN: \"{{ .Values.domain }}\"\n  CORS_ORIGIN: \"{{ .Values.domain }}\"\n</code></pre> <p>And finally used in our nginx config template, and backend CORS settings:</p> default.conf.template<pre><code>server {\n    listen 80;\n    server_name $DOMAIN;\n}\n</code></pre>"},{"location":"ci_cd/#2-cicd-pipeline","title":"2. CI/CD Pipeline","text":"<p>Currently, our CI/CD setup is functional but partially manual. Code changes are pushed to GitHub, and a webhook triggers a sync with CloudLab. However, a user must still log into CloudLab and instantiate the deployment manually.</p> <p>Our goal is to evolve this into a fully automated pipeline using GitHub Actions and the CloudLab PortalAPI.</p>"},{"location":"ci_cd/#a-continuous-integration-ci","title":"A. Continuous Integration (CI)","text":"Current Webhook-Based Workflow <p>The current workflow uses a GitHub webhook that sends a <code>POST</code> request to a CloudLab endpoint when code is pushed. That endpoint simply pulls the latest changes \u2014 but does not instantiate the deployment automatically.</p> <pre><code>flowchart LR\n    A[Push to GitHub] --&gt; B[GitHub Webhook Fires]\n    B --&gt; C[CloudLab Webhook Endpoint]\n    C --&gt; D[CloudLab Repository Updates]\n    D --&gt; E[\"Manual Profile Instantiation (User)\"]\n    E --&gt; F[Run Startup Scripts]</code></pre> Future CI Plans: <p>We are planning to integrate GitHub Actions with the CloudLab PortalAPI. On push this would:</p> <ul> <li>Automatically instantiate the profile</li> <li>SSH into the node</li> <li>Tail deployment logs </li> <li>Optionally run e2e tests after deploy (if we have time)</li> </ul> <pre><code>flowchart LR\n    A[Code Push to GitHub] --&gt; B[GitHub Action Triggered]\n    B --&gt; C[Call CloudLab PortalAPI]\n    C --&gt; D[Instantiate Profile]\n    D --&gt; E[SSH into Node + Run Startup Script]\n    E --&gt; F[Live Deployment Logs + Health Checks]\n    F --&gt; G[\"Run Tests (optional)\"]</code></pre>"},{"location":"ci_cd/#b-continous-deployment-cd","title":"B. Continous Deployment (CD)","text":"1. Instantiation <p>Once our project is instantiated, <code>profile.py</code> starts the deployment process with this line:</p> profile.py<pre><code>node.addService(pg.Execute(\n    shell=\"sh\",\n    command=(\n        \"sudo bash /local/repository/deploy_scripts/install_deps.sh \"\n        \"&amp;&amp; sudo -u ccuser -i bash /local/repository/deploy_scripts/startup.sh\"\n    )\n))\n</code></pre> <p>This does two things:</p> <ol> <li>Runs <code>install_deps.sh</code> as root \u2013 installs Docker, Minikube, Skaffold, kubectl, and Helm.</li> <li>Runs <code>startup.sh</code> as a non-root user (<code>ccuser</code>) \u2013 starts Minikube, enables ingress, patches the controller, sets up port forwarding, and deploys via Skaffold.</li> </ol> <p>Security Concerns</p> <ul> <li> <p>Root access is used only where necessary (system-level package installs, permissions).</p> </li> <li> <p>The rest of the app lifecycle runs under a limited, non-root user for security and isolation.</p> </li> </ul> 2. install_deps.sh <p>This script installs dependencies like Docker, Minikube, Skaffold, and Helm, and provisions the non-root deployment user: <code>ccuser</code></p> install_deps.sh<pre><code>USERNAME=ccuser\n\nif ! id \"$USERNAME\" &amp;&gt;/dev/null; then\n  adduser --disabled-password --gecos \"\" $USERNAME\n  usermod -aG docker $USERNAME\n  usermod -aG sudo $USERNAME\n  echo \"$USERNAME ALL=(ALL) NOPASSWD:ALL\" &gt; /etc/sudoers.d/$USERNAME\n  chmod 0440 /etc/sudoers.d/$USERNAME\nfi\n</code></pre> <ul> <li><code>ccuser</code> is created </li> <li>The user is added to the <code>docker</code> group so it can run Docker containers.</li> <li>All non-critical operations like starting Minikube, forwarding ports, and deploying with Skaffold are executed under this non-root user.</li> <li>Logs are outputed to <code>/local/logs/install.log</code></li> </ul> 3. startup.sh <p>This script is run as the non-root user <code>ccuser</code> and handles cluster initialization, ingress setup, port forwarding, and application deployment.</p>"},{"location":"ci_cd/#1-start-minikube","title":"1. Start Minikube","text":"<pre><code>minikube start --driver=docker\n</code></pre>"},{"location":"ci_cd/#2-enable-the-nginx-ingress-addon","title":"2. Enable the NGINX Ingress Addon","text":"<pre><code>minikube addons enable ingress\n</code></pre> <p>This installs the NGINX Ingress Controller, which acts as a reverse proxy that routes incoming HTTP(S) requests to the  Kubernetes frontend service. </p>"},{"location":"ci_cd/#3-patch-the-ingress-controller-to-loadbalancer","title":"3. Patch the Ingress Controller to <code>LoadBalancer</code>","text":"<pre><code>kubectl patch svc ingress-nginx-controller \\\n  -n ingress-nginx \\\n  -p '{\"spec\": {\"type\": \"LoadBalancer\"}}'\n</code></pre> <p>By default, Minikube deploys the ingress controller as a <code>ClusterIP</code> service, which means it\u2019s only reachable from inside the cluster. This patch changes it to <code>LoadBalancer</code>, allowing traffic to be routed from outside the cluster.</p>"},{"location":"ci_cd/#4-start-the-minikube-tunnel","title":"4. Start the Minikube Tunnel","text":"<pre><code>echo \"password\" | sudo -S nohup minikube tunnel &gt; /local/logs/tunnel.log 2&gt;&amp;1 &amp;\n</code></pre> <p>This command starts a tunnel background process that makes LoadBalancer services accessible from outside the cluster.</p>"},{"location":"ci_cd/#5-use-socat-to-forward-port-80","title":"5. Use socat to Forward Port 80","text":"<pre><code>echo \"password\" | sudo -S nohup socat TCP-LISTEN:80,fork TCP:192.168.49.2:80 &gt; /local/logs/socat.log 2&gt;&amp;1 &amp;\n</code></pre> <p>Even with the tunnel running, CloudLab doesn\u2019t let us bind directly to port 80 on the public network interface. To get around this, we use socat, to listen on port 80 and forward incoming traffic to the internal <code>Minikube ingress IP</code>. This makes the app accessible from a browser using the node\u2019s hostname, even though it\u2019s running inside Minikube.</p> <p>This makes the app reachable from:</p> <pre><code>http://$(hostname -f)\n</code></pre>"},{"location":"ci_cd/#6-deploy-the-application-with-skaffold","title":"6. Deploy the Application with Skaffold","text":"<pre><code>skaffold run -p prod\n</code></pre> <p>This command deploys the app using the production profile. The <code>prod</code> profile dynamically injects the correct domain as described above in <code>Skaffold</code>.</p> <pre><code>setValueTemplates:\n  domain: '{{cmd \"hostname\" \"-f\"}}'\n</code></pre> <p>That hostname is then used by the ingress configuration, nginx templates, and backend CORS logic etc...</p> <p>When the startup process is finished - the script prints:</p> <pre><code>echo \"App should be accessible at: http://$(hostname -f)\"\n</code></pre>"},{"location":"friends/","title":"Friends System","text":"<p>Campus Connect features a fully functional friend system allowing users to:</p> <ul> <li>Send, accept, or deny friend requests</li> <li>Cancel sent requests</li> <li>Remove confirmed friends</li> <li>Block or unblock users</li> <li>View all friend-related lists</li> </ul> <p>All logic is handled through the <code>FriendsService</code>, with routes protected by <code>AuthGuard</code>.</p> <p>Warning</p> <p>Not all features are implemented on the frontend yet</p>"},{"location":"friends/#schema","title":"Schema","text":"<ul> <li>friends: confirmed mutual connections</li> <li>friendRequests: incoming requests</li> <li>sentFriendRequests: outgoing pending requests</li> <li>blockedUsers: users this user has blocked</li> </ul>"},{"location":"friends/#friend-api-endpoints","title":"Friend API Endpoints","text":"<p>All endpoints require a valid session and are guarded by <code>AuthGuard</code>.</p>"},{"location":"friends/#send-friend-request","title":"Send Friend Request","text":"<p>POST <code>/friends/request</code></p> <pre><code>{ \"target\": \"bob@example.com\" }\n</code></pre> <ul> <li><code>target</code> can be user ID, email, or username</li> <li>Cannot send to self</li> <li>Cannot send to already-friended user</li> <li>Cannot send if already pending</li> </ul>"},{"location":"friends/#accept-friend-request","title":"Accept Friend Request","text":"<p>POST <code>/friends/accept</code></p> <pre><code>{ \"target\": \"bob@example.com\" }\n</code></pre> <ul> <li>Moves user to <code>friends</code></li> <li>Removes from <code>friendRequests</code> and their <code>sentFriendRequests</code></li> </ul>"},{"location":"friends/#deny-friend-request","title":"Deny Friend Request","text":"<p>POST <code>/friends/deny</code></p> <pre><code>{ \"target\": \"bob@example.com\" }\n</code></pre> <ul> <li>Simply removes the incoming request</li> <li>No notification sent</li> </ul>"},{"location":"friends/#cancel-friend-request","title":"Cancel Friend Request","text":"<p>POST <code>/friends/cancel</code></p> <pre><code>{ \"target\": \"bob@example.com\" }\n</code></pre> <ul> <li>Removes from your <code>sentFriendRequests</code></li> <li>Removes you from their <code>friendRequests</code></li> </ul>"},{"location":"friends/#remove-friend","title":"Remove Friend","text":"<p>POST <code>/friends/remove</code></p> <pre><code>{ \"target\": \"bob@example.com\" }\n</code></pre> <ul> <li>Removes both users from each other's <code>friends</code> lists</li> </ul>"},{"location":"friends/#block-user","title":"Block User","text":"<p>POST <code>/friends/block</code></p> <pre><code>{ \"target\": \"bob@example.com\" }\n</code></pre> <ul> <li>Adds to <code>blockedUsers</code></li> <li>Automatically removes from:</li> <li><code>friends</code></li> <li><code>friendRequests</code></li> <li><code>sentFriendRequests</code></li> </ul>"},{"location":"friends/#unblock-user","title":"Unblock User","text":"<p>POST <code>/friends/unblock</code></p> <pre><code>{ \"target\": \"bob@example.com\" }\n</code></pre> <ul> <li>Removes target from <code>blockedUsers</code></li> </ul>"},{"location":"friends/#fetch-lists","title":"Fetch Lists","text":""},{"location":"friends/#friends-list","title":"Friends List","text":"<p>POST <code>/friends/friendsList</code></p> <p>Response:</p> <pre><code>{\n  \"friends\": [\n    { \"id\": \"abc123\", \"username\": \"bob\" },\n    { \"id\": \"xyz456\", \"username\": \"carol\" }\n  ]\n}\n</code></pre>"},{"location":"friends/#incoming-requests","title":"Incoming Requests","text":"<p>POST <code>/friends/getIncomingRequests</code></p> <p>Response:</p> <pre><code>{\n  \"requests\": [\n    { \"id\": \"xyz456\", \"username\": \"carol\" }\n  ]\n}\n</code></pre>"},{"location":"friends/#sent-requests","title":"Sent Requests","text":"<p>POST <code>/friends/getSentRequests</code></p> <p>Response:</p> <pre><code>{\n  \"requests\": [\n    { \"id\": \"bob123\", \"username\": \"bob\" }\n  ]\n}\n</code></pre>"},{"location":"friends/#blocked-users","title":"Blocked Users","text":"<p>POST <code>/friends/getBlockedUsers</code></p> <p>Response:</p> <pre><code>{\n  \"blockedUsers\": [\n    { \"id\": \"block1\", \"username\": \"enemy\" }\n  ]\n}\n</code></pre>"},{"location":"friends/#validation-errors","title":"Validation &amp; Errors","text":"Scenario Error Send to self 400 Bad Request Already friends 400 Bad Request Already sent request 400 Bad Request No incoming request to accept 400 Bad Request Remove non-friend 400 Bad Request Blocked already 400 Bad Request Unblock non-blocked 400 Bad Request Nonexistent user 404 Not Found"},{"location":"friends/#notes","title":"Notes","text":"<ul> <li>The system uses MongoDB array fields for relationships</li> <li>All lookups are done using flexible <code>findByIdentifier()</code>:<ul> <li>Accepts ID, email, or username</li> </ul> </li> <li>Notifications are sent (real-time) when:<ul> <li>A request is received</li> <li>A request is accepted</li> </ul> </li> </ul>"},{"location":"local-deployment/","title":"Local Deployment","text":""},{"location":"local-deployment/#1-requirements","title":"1. Requirements","text":"<p>Before starting the deployment, ensure you have the following tools installed and configured:</p> Tool Description Install Link Docker Desktop Containerization platform for local development. Install Docker Minikube Run a local Kubernetes cluster. Install Minikube Skaffold Automate the build and deployment cycle. Install Skaffold kubectl Interact with the Kubernetes cluster. Install kubectl Helm Manage and deploy Kubernetes packages. Install Helm Docker Desktop Setup on Windows <p>If you're using Docker on Windows, follow these steps:</p> <ol> <li>Open Docker Desktop.</li> <li>Go to Settings &gt; Resources &gt; WSL Integration.</li> <li>Enable \u201cIntegration with my default WSL distro\u201d.</li> <li>Check Ubuntu under \"Enable integration with additional distros:\"</li> <li>Click Apply and Restart to apply your changes.</li> </ol> <p></p>"},{"location":"local-deployment/#2-local-deployment","title":"2. Local Deployment","text":"<p>The scripts <code>install_deps.sh</code> and <code>startup.sh</code> in <code>/deploy_scripts</code> are designed for deployment in a CI/CD pipeline on a linux environment like CloudLab. These can be referenced here.</p>"},{"location":"local-deployment/#step-1-start-minikube","title":"Step 1: Start Minikube","text":"<p>Open a new WSL terminal in the project root, and start the Kubernetes cluster using Minikube with Docker as the driver:</p> <pre><code>minikube start --driver=docker\n</code></pre>"},{"location":"local-deployment/#step-2-enable-the-nginx-ingress-addon","title":"Step 2: Enable the NGINX Ingress Addon","text":"<p>Enable the ingress addon to manage external traffic:</p> <pre><code>minikube addons enable ingress\n</code></pre> <p>This command installs the NGINX ingress controller that will handle routing HTTP requests into the Kubernetes cluster.</p>"},{"location":"local-deployment/#step-3-patch-the-ingress-controller","title":"Step 3: Patch the Ingress Controller","text":"<p>Patch the ingress controller\u2019s service to change its type to <code>LoadBalancer</code> so that it can be accessed externally:</p> <pre><code>kubectl patch svc ingress-nginx-controller \n    -n ingress-nginx \n    -p '{\"spec\": {\"type\": \"LoadBalancer\"}}'\n</code></pre> <p>Note</p> <p>By default, the NGINX Ingress controller is exposed as a <code>ClusterIP</code> service, which is only reachable from within the cluster. Patching it to <code>LoadBalancer</code> changes the service type to expose a network-accessible IP address.</p>"},{"location":"local-deployment/#step-4-start-the-minikube-tunnel","title":"Step 4: Start the Minikube Tunnel","text":"<p>Run the tunnel to expose LoadBalancer services on your host network:</p> <pre><code>minikube tunnel\n</code></pre> <p>Warning</p> <p>Keep this terminal open because the tunnel is active only while the terminal is running. You should create a new terminal for the next steps or run <code>minikube tunnel</code> in a standalone terminal. </p>"},{"location":"local-deployment/#step-5-deploy-with-skaffold-development-profile","title":"Step 5: Deploy with Skaffold (Development Profile)","text":"<p>For local development, use the <code>dev</code> profile to set the hostname to <code>localhost</code>:</p> <pre><code>skaffold run -p dev\n</code></pre>"},{"location":"mongo/","title":"Database Schema","text":"<p>Campus Connect uses MongoDB with Mongoose to store user data, channels, and messages. The structure was designed to separate concerns, allow for scalability, and support real-time messaging.</p> <p>All documents are stored in three main collections:</p> <ul> <li><code>users</code></li> <li><code>channels</code></li> <li><code>messages</code></li> </ul> <p>This structure ensures that channels remain lightweight and that messages can be created, queried, and updated efficiently.</p> User Schema \u2013 <code>users</code> Collection users.schema.ts<pre><code>{\n    _id: string,\n    email: string,\n    username: string,\n    password: string, // Hashed\n    campus: string,\n\n    // Social Graph\n    friends: string[],\n    friendRequests: string[],\n    sentFriendRequests: string[],\n    blockedUsers: string[],\n\n    createdAt: Date,\n    updatedAt: Date\n}\n</code></pre> <ul> <li>Users can send and receive friend requests, block others, and maintain a list of confirmed friends.<ul> <li>(not all features have been implmented on the front end yet)</li> </ul> </li> <li>All relationships are stored as array of user IDs (strings), making it easier to join or populate as needed.</li> <li>Passwords are hashed before storage (using bcrypt).</li> </ul> Channel Schema \u2013 <code>channels</code> Collection channel.schema.ts<pre><code>{\n    _id: string,\n    type: 'DM' | 'GROUP',\n    name?: string,\n    participants: string[], // User IDs\n\n    createdAt: Date,\n    updatedAt: Date\n}\n</code></pre> <ul> <li>A channel can be either a DM (direct message between two users) or a GROUP (future support).</li> <li>The list of participants is stored as an array of user IDs.</li> <li>Channels are deliberately lightweight \u2013 no messages are embedded.</li> </ul> Message Schema \u2013 <code>messages</code> Collection message.schema.ts<pre><code>{\n    _id: string,\n    channelId: string,\n    senderId: string,\n    senderName?: string,\n    content: string,\n    edited: boolean,\n\n    createdAt: Date,\n    updatedAt: Date\n}\n</code></pre> <ul> <li>Messages are stored in a separate collection </li> <li>Messages reference both the <code>channelId</code> and <code>senderId</code>.</li> <li>When a message is edited, the <code>edited</code> flag is set to true for transparency.</li> </ul> MongoDB Entity Relationship <pre><code>erDiagram\n    USER ||--o{ CHANNEL : participates_in\n    USER ||--o{ MESSAGE : sends\n    CHANNEL ||--o{ MESSAGE : contains\n\n    USER {\n        string _id\n        string email\n        string username\n        string password\n        string campus\n        string[] friends\n        string[] friendRequests\n        string[] sentFriendRequests\n        string[] blockedUsers\n    }\n\n    CHANNEL {\n        string _id\n        string type\n        string name\n        string[] participants\n    }\n\n    MESSAGE {\n        string _id\n        string channelId\n        string senderId\n        string content\n        boolean edited\n        date createdAt\n    }</code></pre>"},{"location":"redis/","title":"Redis &amp; Session Management","text":"<p>Campus Connect uses Redis to manage encrypted session storage across users and services. This system allows persistent logins, WebSocket authentication, and scalable session state in a stateless backend.</p>"},{"location":"redis/#why-redis","title":"Why Redis?","text":"<p>Redis is used as a fast, in-memory key-value store for session persistence.</p> <ul> <li>Stateless backend: Session data lives in Redis, not in memory</li> <li>Encrypted session payloads</li> <li>Signed cookies for tamper prevention</li> <li>TTL-based expiration for automatic cleanup</li> </ul>"},{"location":"redis/#session-flow","title":"Session Flow","text":"Login Flow Diagram <pre><code>sequenceDiagram\n    participant Browser\n    participant Backend\n    participant Redis\n\n    Browser-&gt;&gt;+Backend: POST /auth/login\n    Backend-&gt;&gt;+Redis: Save encrypted session with userId\n    Redis--&gt;&gt;-Backend: OK\n    Backend--&gt;&gt;-Browser: Set-Cookie: connect.sid\n\n    Browser-&gt;&gt;+Backend: \"GET (Protected Route)\"\n    Backend-&gt;&gt;+Redis: Retrieve + decrypt session\n    Redis--&gt;&gt;-Backend: { userId }\n    Backend--&gt;&gt;-Browser: Serve user data</code></pre>"},{"location":"redis/#session-lifecycle","title":"Session Lifecycle","text":""},{"location":"redis/#1-save-session","title":"1. Save Session","text":"session.service.ts<pre><code>await this.sessionService.saveSession(req, userId);\n</code></pre> <p>Writes the session to Redis under the key <code>session:&lt;sid&gt;</code> after encrypting and stringifying the payload.</p>"},{"location":"redis/#2-retrieve-session","title":"2. Retrieve Session","text":"<ul> <li>From HTTP request: <pre><code>await getUserIdFromCookie(req);\n</code></pre></li> <li>From WebSocket cookie: <pre><code>await getSessionFromRawCookie(rawCookie); \n</code></pre><ul> <li>Used in <code>ChannelsGateway</code> to authenticate socket connections.</li> </ul> </li> </ul>"},{"location":"redis/#3-destroy-session","title":"3. Destroy Session","text":"<pre><code>await destroySession(sessionId);\n</code></pre> <p>Removes the session from Redis and invalidates it.</p>"},{"location":"redis/#redis-key-format","title":"Redis Key Format","text":"<ul> <li>All sessions are stored under the Redis key: <code>session:&lt;sessionId&gt;</code></li> <li>Length: 1 day (86400 seconds)</li> <li>Auto-purged by Redis after expiry</li> </ul>"},{"location":"redis/#session-payload-decrypted","title":"Session Payload (Decrypted)","text":"<pre><code>{\n  \"cookie\": {\n    \"originalMaxAge\": 86400000,\n    \"expires\": \"2025-03-31T00:00:00.000Z\",\n    \"httpOnly\": true,\n    \"secure\": false,\n    \"sameSite\": \"strict\"\n  },\n  \"userId\": \"64f123456789abcdef123456\"\n}\n</code></pre>"}]}